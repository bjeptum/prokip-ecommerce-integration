// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  username  String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  connections Connection[]

  @@map("users")
}

model Connection {
  id        Int     @id @default(autoincrement())
  userId    Int
  platform  String // 'shopify', 'woocommerce'
  storeUrl  String
  storeName String?

  // Shopify fields
  accessToken       String?
  accessTokenSecret String?

  // WooCommerce fields (encrypted)
  consumerKey    String? // JSON string with encrypted data
  consumerSecret String? // JSON string with encrypted data

  // Legacy WooCommerce fields (deprecated)
  wooUsername    String?
  wooAppPassword String?
  wooAppName     String?

  // OAuth fields
  oauthToken  String?
  oauthSecret String?

  lastSync    DateTime @default(now())
  syncEnabled Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  inventoryLogs InventoryLog[]
  salesLogs     SalesLog[]
  webhookEvents WebhookEvent[]
  syncErrors    SyncError[]

  @@unique([userId, platform, storeUrl])
  @@map("connections")
}

model InventoryLog {
  id           Int      @id @default(autoincrement())
  connectionId Int
  productId    String
  productName  String
  sku          String?
  quantity     Int
  price        Float
  lastSynced   DateTime @default(now())

  // Relations
  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Compound unique constraint for upsert operations
  @@unique([connectionId, sku])
  @@map("inventory_logs")
}

model SalesLog {
  id            Int      @id @default(autoincrement())
  connectionId  Int
  orderId       String
  orderNumber   String?
  customerName  String?
  customerEmail String?
  totalAmount   Float
  status        String?
  orderDate     DateTime
  syncedAt      DateTime @default(now())

  // Relations
  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@map("sales_logs")
}

model WebhookEvent {
  id           Int       @id @default(autoincrement())
  connectionId Int
  eventType    String // 'order.created', 'product.updated', etc.
  payload      String // JSON payload
  processed    Boolean   @default(false)
  errorMessage String?
  createdAt    DateTime  @default(now())
  processedAt  DateTime?

  // Relations
  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@map("webhook_events")
}

model ProkipConfig {
  id           Int       @id @default(1)
  token        String
  refreshToken String?
  expiresAt    DateTime?
  apiUrl       String
  locationId   String
  userId       Int       @default(1)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@map("prokip_config")
}

model SyncError {
  id           Int       @id @default(autoincrement())
  connectionId Int
  errorType    String // 'inventory', 'product', 'order', etc.
  errorMessage String
  errorDetails String? // JSON with additional details
  resolved     Boolean   @default(false)
  resolvedAt   DateTime?
  createdAt    DateTime  @default(now())

  // Relations
  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  @@map("sync_errors")
}

// Migration notes:
// 1. Consumer Key and Secret are now stored as encrypted JSON strings
// 2. Legacy fields (wooUsername, wooAppPassword) are kept for backward compatibility
// 3. All connections are now user-scoped (multi-tenant)
// 4. Added proper foreign key constraints with cascade delete
// 5. Added proper indexing for performance
